Metadata-Version: 2.1
Name: pimtorch
Version: 0.1.1
Summary: A python algorithm-hardware co-design framework for memristor-based in-memory computing.
Home-page: https://github.com/lanceyang694
Author: Ling Yang, Houji, Zhou, et al.
Author-email: 3299285328@qq.com
Maintainer: Researchers from Prof. Yi Li's group at HUST
License: MIT
Requires-Python: >=3.6
Description-Content-Type: text/markdown
License-File: LICENSE.txt
Requires-Dist: numpy
Requires-Dist: scipy
Requires-Dist: matplotlib
Requires-Dist: pandas
Requires-Dist: torch

# PimTorch: A Software-Hardware Co-Design Simulator for Memristor-Based In-Memory Computing

## *Make in-memory computing as easy as np.dot (Torch version)!*

In memory computing technology is a potential solution to overcome the von Neumann bottleneck and to provide significant improvements in energy efficiency. However, for in-memory computing, the algorithm and hardware are highly intertwined, making it challenging to design an optimal circuit. To address this issue, the author developed a Python package named "mPimPy" that embeds hardware simulation into the algorithm. From a user's perspective, mPimPy serves as the equivalent of the Numpy.dot function to implement the matrix multiplication which is the key operation of neural networks, machine learning, signal processing, and scientific computing. By simply replacing the `np.dot` function in your original code with `MapReducedot` and rerunning your program, you can simulate scenarios such as neural networks or any algorithm involving matrix multiplications. Whether you are a computer engineer or a microelectronic scientist, mPimPy enables you to quickly deploy your code on in-memory computing hardware or verify your circuit design solutions. 

## Note
Although this package can realize part of the function in 'main' branch, it lacks the support for FP data and line resistance.

The aim of this torch version mpimpy is to simulate memristive VMM in deep learning layers including the convolution and FC layers. 
The full version of the package will be released recently.

## Installing

Currently, mpimpy torch version is in development, and it can only be installed from the source code.


```shell
git clone -b mpimpy-torch https://github.com/lanceyang694/mpimpy.git

cd mpimpy

#---------------------------------------------------
#       method 1: write code in this dictionary
#---------------------------------------------------
# install the package
pip install -r requirements.txt

# change to the files in mpimpy-torch
cd mpimpy-torch
# new files in this dictionary and run

#---------------------------------------------------
#       method 2: install the package
#---------------------------------------------------
# install the package
python setup.py install

#---------------------------------------------------
#       method 3: install the package by pip
#---------------------------------------------------
cd dist
pip install pimtorch-0.0.4-py3-none-any.whl

```

## Version Information
### 0.0.1   
For INT data support only
### 0.0.2
We add the FP data support fot the dataformat
Changed the consideration for the batch input data
### 0.0.3
Update includes:
- Added support for different splitting granularity of input data
  - The input data can be sliced by the matrix mode and row mode
  - It is controlled by "input_en" in class "SlicedData"
- Added support for different splitting granularity of weight
  - For FP data, the data slice can support the double exponet quantization

## Example

```python
from matplotlib import pyplot as plt
from memmat_tensor import DPETensor
from data_formats import SlicedData

    
tb_mode = 1
if tb_mode == 0:
    x_data = torch.randn(1000, 100)
    mat_data = torch.randn(100, 800)
    mblk = xblk = torch.tensor(10 * [1] + 5 * [2])
    mat = SlicedData(mblk, bw_e=8)
    x = SlicedData(xblk, bw_e=8, input_en=True)
    engine = DPETensor(var=0.0, array_size=(32,32), input_size=(32,32))
    mat.slice_data_imp(engine, mat_data)
    x.slice_data_imp(engine, x_data)
    start = time.time()
    result = engine(x, mat).numpy()
    end = time.time()
    print("Tensor time: ", end - start)

    rel_result = torch.matmul(x_data, mat_data).numpy()
    print(RE(result, rel_result))
    plt.scatter(rel_result.reshape(-1), result.reshape(-1))
    plt.xlabel('Expected Value of Dot Product')
    plt.ylabel('Measured Value of Dot Product')
    plt.show()

elif tb_mode == 1:
    torch.manual_seed(42)
    device = torch.device('cuda:0')
    x_data = torch.randn(3, 1000, 1000, device=device)
    mat_data = torch.randn(1000, 1200, device=device)
    xblk = torch.tensor([1, 1, 2, 4])
    mblk = torch.tensor([1, 1, 2, 4])
    
    mat = SlicedData(mblk, device=device)
    x = SlicedData(xblk, device=device, input_en=True)

    engine = DPETensor(var=0.05, array_size=(64,64), input_size=(64,64))
    x.slice_data_imp(engine, x_data)
    mat.slice_data_imp(engine, mat_data)
    start = time.time()
    result = engine(x, mat)
    end = time.time()
    print("Tensor time: ", end - start)
    result = result.cpu().numpy()

    rel_result = torch.matmul(x_data, mat_data).cpu().numpy()

    print(RE(result, rel_result))
    plt.scatter(rel_result.reshape(-1), result.reshape(-1))
    plt.xlabel('Expected Value of Dot Product')
    plt.ylabel('Measured Value of Dot Product')
    plt.show()

```

## Author

Author: Ling Yang

Email: [3299285328@qq.com](mailto:3299285328@qq.com)

## Contributors

- Houji Zhou, [1499403578@qq.com](mailto:1499403578@qq.com), [zhouhouji (houjizhou) Â· GitHub](https://github.com/zhouhouji)

- Zhiwei Zhou, [1548384176@qq.com](mailto:1548384176@qq.com)

- Yuyang Fu, [412983100@qq.com](mailto:412983100@qq.com)

## Maintainer

- Maintainer: Researchers from Prof. Xiangshui Miao and Prof. Yi Li's group at HUST

- Affiliation: Huazhong University of Science and Technology, School of Integrated Circuit,  [Institute of Information Storage Materials and Devices (hust.edu.cn)](http://ismd.hust.edu.cn/)

Any advice and criticism are highly appreciated on this package. Naturally, you can also modify the source code to suit your needs. In upcoming versions, we plan to continually incorporate the latest research findings into mPimPy. Stay tuned!

## References

[1] [Zidan M A, Jeong Y J, Lee J, et al. A general memristor-based partial differential equation solver[J]. Nature Electronics, 2018, 1(7): 411-420.](https://www.nature.com/articles/s41928-018-0100-6)

[2] [Li C, Hu M, Li Y, et al. Analogue signal and image processing with large
 memristor crossbars[J]. Nature electronics, 2018, 1(1): 52-59.](https://www.nature.com/articles/s41928-017-0002-z)
